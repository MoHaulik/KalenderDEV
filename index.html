<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calendar Editor</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%);
            overflow: hidden;
            flex-direction: column;
            gap: 20px; /* Space between calendar and the new box */
        }

        .calendar-container {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 20px;
            color: rgba(0, 0, 0, 0.8);
        }

        #header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            box-sizing: border-box;
        }

        #date-container {
            text-align: left;
        }

        #date, #day-name, #month-name {
            font-size: 24px;
            margin: 0;
            line-height: 1.2;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        #editor {
            width: 100%;
            height: calc(100% - 60px);
            border: none;
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-y: auto;
            margin-top: 10px;
            box-sizing: border-box;
            font-size: 26px;
            background: transparent;
            color: inherit;
            padding: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .clickable {
            cursor: pointer;
            transition: text-decoration 0.3s ease;
        }

        .clickable:hover {
            text-decoration: underline;
        }

        /* New Class for Done Tasks */
        .done {
            text-decoration: line-through;
        }

        /* New Box Styling */
        .avatar-box {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            align-items: center;
            border-radius: 20px;
            gap: 15px; /* Space between avatar and text */
            cursor: pointer;
        }

        .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .text-bubble {
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 15px;
            color: rgba(0, 0, 0, 0.8);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);
            flex-grow: 1;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .calendar-container, .avatar-box {
                width: 90%;
                padding: 15px;
            }

            #date, #day-name, #month-name {
                font-size: 20px;
            }

            #editor {
                font-size: 22px;
            }

            .text-bubble {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="calendar-container">
        <div id="header">
            <div id="date-container">
                <div id="date"></div>
                <div id="month-name"></div>
            </div>
            <div id="day-name"></div>
        </div>
        <div id="editor" contenteditable="true"></div>
    </div>

    <!-- New Box for Avatar and Text Bubble -->
    <div class="avatar-box" onclick="openChat()">
        <div class="avatar">
            <img src="Avatar.jpeg" alt="Avatar">
        </div>
        <div class="text-bubble" id="greeting-message">
            <!-- Placeholder for text bubble content -->
        </div>
    </div>

    <script>
        const editor = document.getElementById('editor');
        const dayNameElement = document.getElementById('day-name');
        const dateElement = document.getElementById('date');
        const monthNameElement = document.getElementById('month-name');

        const danishDays = ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'];
        const danishMonths = ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'];

        const startDate = 3; // October 3
        const startMonth = 9; // October (0-based index)
        const endMonth = 11; // December (0-based index)
        const year = 2024;

        const canvasKeys = [];
        let totalDays = 0;

        for (let month = startMonth; month <= endMonth; month++) {
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const startDay = month === startMonth ? startDate : 1;
            for (let day = startDay; day <= daysInMonth; day++) {
                canvasKeys.push(`canvas${year}${(month + 1).toString().padStart(2, '0')}${day.toString().padStart(2, '0')}`);
                totalDays++;
            }
        }

        let currentCanvasIndex = 0;
        let typingTimer;
        const typingDelay = 1000; // 1 second delay
        const clickableDelay = 10000; // 10 seconds delay

        const hoverSound = new Audio('Hover.wav');
        const clickSound = new Audio('click.mp3');

        // Load canvases from localStorage or initialize them
        const canvases = canvasKeys.map(key => {
            const stored = localStorage.getItem(key);
            return stored ? JSON.parse(stored) : [];
        });

        function updateEditor() {
            let currentDay = startDate;
            let currentMonth = startMonth;
            for (let i = 0; i < currentCanvasIndex; i++) {
                currentDay++;
                if (currentDay > new Date(year, currentMonth + 1, 0).getDate()) {
                    currentDay = 1;
                    currentMonth++;
                }
            }
            const date = new Date(year, currentMonth, currentDay);
            dayNameElement.innerText = danishDays[date.getDay()];
            dateElement.innerText = currentDay;
            monthNameElement.innerText = danishMonths[currentMonth];
            renderTasks();
        }

        function saveCurrentCanvas() {
            const tasks = [];
            editor.childNodes.forEach(node => {
                if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('clickable')) {
                    tasks.push({
                        text: node.textContent,
                        done: node.classList.contains('done')
                    });
                } else if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
                    tasks.push({
                        text: node.textContent.trim(),
                        done: false
                    });
                }
            });
            canvases[currentCanvasIndex] = tasks;
            localStorage.setItem(canvasKeys[currentCanvasIndex], JSON.stringify(tasks));
        }

        function translateText(text) {
            return text
                .replace(/;/g, 'æ')
                .replace(/'/g, 'ø')
                .replace(/\[/g, 'å')
                .replace(/\b(\d{2})(\d{2})\b/g, '$1.$2');
        }

        function setCurrentCanvasIndex() {
            const today = new Date();
            if (today >= new Date(year, startMonth, startDate) && today <= new Date(year, endMonth + 1, 0)) {
                const daysSinceStart = Math.floor((today - new Date(year, startMonth, startDate)) / (1000 * 60 * 60 * 24));
                currentCanvasIndex = Math.min(daysSinceStart, totalDays - 1);
            } else {
                currentCanvasIndex = 0;
            }
        }

        function showPreviousCanvas() {
            saveCurrentCanvas();
            currentCanvasIndex = (currentCanvasIndex === 0) ? canvases.length - 1 : currentCanvasIndex - 1;
            hoverSound.play();
            updateEditor();
        }

        function showNextCanvas() {
            saveCurrentCanvas();
            currentCanvasIndex = (currentCanvasIndex === canvases.length - 1) ? 0 : currentCanvasIndex + 1;
            hoverSound.play();
            updateEditor();
        }

        function makeTextClickable() {
            const textNodes = editor.childNodes;
            textNodes.forEach(node => {
                if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() !== '') {
                    const span = document.createElement('span');
                    span.textContent = node.textContent;
                    span.classList.add('clickable');
                    node.replaceWith(span);
                }
            });
        }

        function renderTasks() {
            editor.innerHTML = '';
            const tasks = canvases[currentCanvasIndex] || [];
            tasks.forEach(task => {
                const span = document.createElement('span');
                span.textContent = task.text;
                span.classList.add('clickable');
                if (task.done) {
                    span.classList.add('done');
                }
                editor.appendChild(span);
                editor.appendChild(document.createElement('br'));
            });
        }

        function handleClick(event) {
            if (event.target.classList.contains('clickable')) {
                event.target.classList.toggle('done');
                clickSound.play();
                saveCurrentCanvas();
            }
        }

        function openChat() {
            window.open('https://huggingface.co/chat/', '_blank');
        }

        // Select greeting message based on time of day
        function selectGreeting() {
            const morningMessages = [
                "Morning, Mr. M! How about we kick things off with today’s game plan?",
                "Good morning, Mr. M! Let’s set our sights on a productive day!"
                // Add more morning messages here
            ];
            const afternoonMessages = [
                "Good afternoon, Mr. M! How’s the day going? Ready to map out what's next?",
                "Hey Mr. M! Let’s take a quick look at the afternoon's plan."
                // Add more afternoon messages here
            ];
            const eveningMessages = [
                "Good evening, Mr. M! Shall we go over the day's accomplishments?",
                "Hey Mr. M! Let’s recap and prep for tomorrow!"
                // Add more evening messages here
            ];

            const now = new Date();
            const hours = now.getHours();
            let message;

            if (hours >= 5 && hours < 12) { // Morning: 5 AM - 12 PM
                message = morningMessages[Math.floor(Math.random() * morningMessages.length)];
            } else if (hours >= 12 && hours < 18) { // Afternoon: 12 PM - 6 PM
                message = afternoonMessages[Math.floor(Math.random() * afternoonMessages.length)];
            } else { // Evening: 6 PM - 5 AM
                message = eveningMessages[Math.floor(Math.random() * eveningMessages.length)];
            }

            document.getElementById('greeting-message').innerText = message;
        }

        // New Function: Handle conversion when '.' is typed
        function handleDotConversion() {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const node = range.startContainer;

            // Ensure we're dealing with a text node
            if (node.nodeType !== Node.TEXT_NODE) return;

            const text = node.textContent;
            const dotIndex = text.lastIndexOf('.');

            // If a '.' is found at the end of the text
            if (dotIndex === text.length - 1) {
                const beforeDot = text.slice(0, dotIndex).trim();

                if (beforeDot.length === 0) return; // Avoid empty lines

                // Replace the text node with a clickable span
                const span = document.createElement('span');
                span.classList.add('clickable');
                span.textContent = beforeDot;

                // Replace the text node with the span
                node.parentNode.replaceChild(span, node);

                // Insert a line break after the span
                const br = document.createElement('br');
                span.parentNode.insertBefore(br, span.nextSibling);

                // Move the cursor to the new line after the line break
                const newRange = document.createRange();
                newRange.setStartAfter(br);
                newRange.collapse(true);

                // Update the selection to the new range
                selection.removeAllRanges();
                selection.addRange(newRange);

                // Save the updated content
                saveCurrentCanvas();
            }
        }

        // Modified input event listener
        editor.addEventListener('input', () => {
            clearTimeout(typingTimer);
            typingTimer = setTimeout(() => {
                const translatedText = translateText(editor.innerText);
                if (translatedText !== editor.innerText) {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const cursorPosition = range.startOffset;
                        editor.innerText = translatedText;
                        const newRange = document.createRange();
                        newRange.setStart(editor.firstChild, cursorPosition);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }

                // Handle immediate conversion if '.' is typed
                handleDotConversion();

                // Save the current canvas
                saveCurrentCanvas();

                // Schedule delayed clickable conversion for other texts
                setTimeout(makeTextClickable, clickableDelay);
            }, typingDelay);
        });

        // Prevent default behavior for Enter key to insert <br> instead of creating new paragraphs
        editor.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                document.execCommand('insertHTML', false, '<br><br>');
            }
        });

        // Event listeners for navigation and clicking
        dateElement.addEventListener('click', showPreviousCanvas);
        dayNameElement.addEventListener('click', showNextCanvas);
        editor.addEventListener('click', handleClick);

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                showPreviousCanvas();
            } else if (e.key === 'ArrowRight') {
                showNextCanvas();
            }
        });

        // Initialize
        setCurrentCanvasIndex();
        updateEditor();
        selectGreeting(); // Set the greeting message based on the current time
    </script>
</body>
</html>
